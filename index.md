  <figure>  <img
            src="https://raw.githubusercontent.com/AndreiVladescu/Exploiting-DIR-600-Router/refs/heads/main/images/banner.jpg"
            alt="Exploiting the router"
        >  </figure>

# Introduction

This project aims to provide a hands-on training/tutorial for begginers into IoT hacking. I myself gained a great deal in knowledge by doing things, instead of just reading articles online, so if you can, then try replicate these techniques on old hardware. Make sure you **don't** need them, before starting to work on them.

![DIR-600](https://raw.githubusercontent.com/AndreiVladescu/Exploiting-DIR-600-Router/refs/heads/main/images/dir-600.jpg)

I had this old router laying around, so I decided to try my hand at finding some vulnerabilities, exploiting them, and maybe even giving the router a new purpose, instead of just using it for target practice.

# Information Gathering

## Sources of information

 - Online resources
	 - Manufacturer's website
	 - FCC
	 - Blogs
 - Photos
	 - Backside of the router
	 - Take it apart
 - Console Output
 - Pinouts of ICs
 - Firmware extraction
	 - Manufacturer's website
	 - Blogs
	 - Manual SPI flash extraction
	 
## Gathering Phase

### Online resources

[Official D-link website](https://support.dlink.com.au/download/download.aspx?product=DIR-600)
 - Can download firmware of the device 
 - Can establish a path towards the vulnerabilities patched through updates
 - Default login users and password of web user interface "admin" and blank
   

[FCCID.io](https://fccid.io/KA2IR600B5)
 - Can gain info about the performance of the device
 - Can see the insides before taking it apart

[wikidev.wi-cat.ru](https://wikidevi.wi-cat.ru/D-Link_DIR-600_rev_B5)

 - Details of FCC and IC IDs
 - Flash and RAM of the hardware version revision B5
 - Exposed 4-pin serial hardware interface
 - Default login users and password of web user interface "admin" and blank password

### Pinouts of ICs

- [ Ralink RT5350 SoC](https://cdn.sparkfun.com/datasheets/Wireless/WiFi/RT5350.pdf)
- [Winbond W25Q32BV SPI Flash](https://www.alldatasheet.com/datasheet-pdf/download/555293/WINBOND/25032BVSIG.html)
- [Winbond W9825G6JH SDRAM](https://www.alldatasheet.com/datasheet-pdf/download/443883/WINBOND/W9825G6JH.html)
- [Richtek RT8267 Step-Down Converter](https://www.alldatasheet.com/datasheet-pdf/download/474951/RICHTEK/RT8267.html)
	
### Console output
find uart port and connect to it
find jtag port and connect to it
	
### Manual SPI flash extraction
Extracting the flash memory of a target device can be done by manipulating the previously-found flash memory. The target flash has as protocol SPI. You can get away by [using a cheap Arduino to extract the memory](https://github.com/nfd/spi-flash-programmer) and then writing it on the PC for analysis.

While this can be done on a tight budget, it won't give you neither speed nor flexibility for some types of memory. I used the XGecu T48 Flash Programmer for this job, as it supports lots of memory ICs and also microcontrollers. 

I wired it using a clip-on to the flash, and dumped the contents on the disk. Not disconnecting the flash from the SoC can have consequences, as the SoC could receive power from the flash and try to run, so if this happens, desolder it first.  



Firmware inspection incoming
	
# Firmware Analysis

Some tips before starting to analyze the firmware can be found on [Hacktricks](https://book.hacktricks.xyz/hardware-physical-access/firmware-analysis).

## Bird's eye-view

In this phase, the firmware is a single 4MB file, that's ready to be decompressed properly. We can firstly analyze it using binvis.io.

<p align="center">
  <img src="https://raw.githubusercontent.com/AndreiVladescu/Exploiting-DIR-600-Router/refs/heads/main/images/entropy_scale.png" alt="Entropy Scale" width="89"/>
  <img src="https://raw.githubusercontent.com/AndreiVladescu/Exploiting-DIR-600-Router/refs/heads/main/images/byteclass_scale.png" alt="Byteclass Scale" width="80"/>
</p>
The term byte class refers to a classification system used to categorize individual bytes of a binary file based on their value, while entropy refers to a measure of the "randomness"or "uncertainty" in data.

This means that we can visualize where the human-readable data could be and where compressed or encrypted is found.

<p align="center">
  <img src="https://raw.githubusercontent.com/AndreiVladescu/Exploiting-DIR-600-Router/refs/heads/main/images/W25Q32BV_entropy.png" alt="entropy" width="280"/>
  <img src="https://raw.githubusercontent.com/AndreiVladescu/Exploiting-DIR-600-Router/refs/heads/main/images/W25Q32BV_byteclass.png" alt="byteclass" width="280"/>
</p>

After this visual inspection, it is more clear how this memory was split. Some ASCII data is found in the blue spaces, while the other data is more random. To get more details we can use `binwalk`.

![Binwalk](https://raw.githubusercontent.com/AndreiVladescu/Exploiting-DIR-600-Router/refs/heads/main/images/kali_binwalk.png)
We can see at which offsets the signatures of different file types was found. The blue spaces we saw earlier where the HTML files and U-Boot strings. 
 
With `binwalk` we can also extract the data found with those signatures. The command to extract it, and also make it recursively is `binwalk -eM`. The extra arguments are "extract" and "Matryoshka", meaning we extract recursively if we find more compressed files.

![Squash-FS](https://raw.githubusercontent.com/AndreiVladescu/Exploiting-DIR-600-Router/refs/heads/main/images/squash-fs.png)

The file system is found under `squashfs-root`, which is a compressed read-only file system that's commonly found on these types of embedded devices. As we can see, it is compressed with LZMA.

When the device boots, the CPU loads the squash file system into RAM, providing redundancy with the  read-only parameter.

I attached the firmware image in the GitHub [repo](https://github.com/AndreiVladescu/Exploiting-DIR-600-Router/blob/main/W25Q32BV.BIN).

## Digging into the files

After revealing the files, we can get to work on analyzing the system and it's files. We have 2 files that can be analyzed, not counting the file system. The first one is called "40010" and it's full of HTML. The second is "50040", and it's a binary. 

![Additional Data](https://raw.githubusercontent.com/AndreiVladescu/Exploiting-DIR-600-Router/refs/heads/main/images/additional_data.png)
Performing an analysis again, with `binwalk`, we can see that it contains a MySQL file, some Netfilter iptables data, Linux kernel version and checksums. Knowing that the squash-fs is kept on read-only, this could be the zone of memory that the SoC writes it's rules, that can be modified at runtime and loaded at boot-time.

After trying to use the MySQL file, I searched the exact header description and found [this](https://www.reddit.com/r/hacking/comments/ak4hy2/understanding_files_hidden_in_image/) Reddit thread, which says that, while binwalk detects a file, it may be a false positive caused by a short file signature inside the target file.

Using `strings` inside this file can be helpful, since we can see what's going on inside the file.  I found  this string when searching: 
`console=ttyS1,57600n8 root=/dev/mtdblock1 noinitrd`
that looks like a console connection on interface ttyS1 at 57600 baudrate.


